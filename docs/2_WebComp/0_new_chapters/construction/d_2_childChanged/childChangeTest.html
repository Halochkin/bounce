<script>

  (function () {

    class ChildChangedRecord {
      #news;
      #old;
      #added;
      #removed;

      constructor(newNodes, oldNodes, added, removed) {
        this.#news = newNodes;
        this.#old = oldNodes;
        this.#added = added;
        this.#removed = removed;
      }

      get newNodes() {
        return Object.freeze(this.#news);
      }

      get oldNodes() {
        return Object.freeze(this.#old);
      }

      get addedNodes() {
        return Object.freeze(this.#added);
      }

      get removedNodes() {
        return Object.freeze(this.#removed);
      }
    }

    function nextSlotMatroschkaHost(el) {
      for (let c of el.childNodes) {
        if (c instanceof HTMLSlotElement)
          return c.getRootNode().host;
      }
    }

    function* slotMatroschkaHosts(el) {
      for (; el; el = nextSlotMatroschkaHost(el))
        yield el;
    }

    function* flatChildNodes(el) {
      for (let i = 0; i < el.childNodes.length; i++) {
        let c = el.childNodes[i];
        if (c instanceof HTMLSlotElement) {
          for (let c2 of c.assignedNodes({flatten: true}))
            yield c2;
        } else {
          yield c;
        }
      }
    }

    //difference between two maps
    //note, if elements are moved around, not added or removed, then this will return {added: [], removed:[]}, which is good.
    function diff(as, bs) {
      if (as.length !== bs.length || !as.every((e, i) => bs[i] === e))
        return {
          added: bs.filter(b => as.indexOf(b) === -1),
          removed: as.filter(a => bs.indexOf(a) === -1)
        };
    }

    const flatChildNodesCache = new WeakMap();
    const moCache = new WeakMap();

    function observeFlatChildNodes(el) {
      let mo = moCache.get(el);
      mo ? mo.disconnect() : mo = new MutationObserver(() => doChildChanged(el));
      for (let obs of slotMatroschkaHosts(el))
        mo.observe(obs, {childList: true});
    }

    function doChildChanged(el) {
      const oldChildren = flatChildNodesCache.get(el) || [];
      const newChildren = Array.from(flatChildNodes(el));
      const d = diff(oldChildren, newChildren);
      if (!d)
        return;
      flatChildNodesCache.set(el, newChildren);
      observeFlatChildNodes(el);
      try {
        el.childChangedCallback(new ChildChangedRecord(newChildren, oldChildren, d.added, d.removed));
      } catch (err) {
        window.dispatchEvent(new Event('Uncaught Error: ' + err.message)); //todo
      }
    }

    //todo this require the childReady callback point to avoid problems during loading construction.
    //todo as a way to bypass this problem, we can simply do all the tests after loading.
    const HTMLElementOG = HTMLElement;

    class ChildChangedHTMLElement extends HTMLElementOG {

      constructor() {
        super();
        this.childReadyCallback(); //todo this is a hack since we don't implement childReady here.
      }

      childReadyCallback() {
        this.childChangedCallback && doChildChanged(this);
      }
    }

    window.HTMLElement = ChildChangedHTMLElement;
  })();
</script>

<body>
<h3>Naive test</h3>
<web-comp c-1>bob</web-comp>

<script>
  class InnerComp extends HTMLElement {

    constructor() {
      super();
      this.attachShadow({mode: "open"});
      this.shadowRoot.innerHTML = `<slot></slot>`;
    }

    childChangedCallback({newNodes, oldNodes, addedNodes, removedNodes}) {
      console.log(this.tagName, newNodes, oldNodes, addedNodes, removedNodes);
    }
  }

  class WebComp extends HTMLElement {

    constructor() {
      super();
      this.attachShadow({mode: "open"});
      this.shadowRoot.innerHTML = `<inner-comp><slot></slot></inner-comp>`;
    }

    childChangedCallback({newNodes, oldNodes, addedNodes, removedNodes}) {
      console.log(this.tagName, newNodes, oldNodes, addedNodes, removedNodes);
    }
  }

  customElements.define('inner-comp', InnerComp);
  customElements.define('web-comp', WebComp);
</script>

<script>
  for (let wc of document.querySelectorAll("web-comp"))
    wc.append(document.createElement('div'));
  setTimeout(() => {
    for (let wc of document.querySelectorAll("web-comp"))
      wc.firstChild.remove();
  })
</script>
</body>